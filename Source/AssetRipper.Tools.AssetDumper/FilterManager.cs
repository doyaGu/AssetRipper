using AssetRipper.Import.Logging;
using AsmResolver.DotNet;
using System.Text.RegularExpressions;

namespace AssetRipper.Tools.AssetDumper;

internal class FilterManager
{
	private readonly Options _options;
	private readonly Regex? _assemblyRegex;
	private readonly Regex? _excludeRegex;
	private readonly Random _random;

	// Pre-compiled patterns for better performance
	private static readonly string[] AutoGeneratedPatterns = {
		"AssemblyInfo.cs", "GlobalAssemblyInfo.cs", "TemporaryGeneratedFile_",
		".NETFramework,Version=", ".AssemblyAttributes.cs", "AssemblyInfo.dll",
		"Temp", ".Designer.cs", ".g.cs", ".g.i.cs"
	};

	private static readonly string[] AutoGeneratedDirectories = {
		"obj", "bin", "Temp", "Library", "Build", ".vs"
	};

	private static readonly string[] UnityProjectIndicators = {
		"Assembly-CSharp", "Assembly-UnityScript", "Assembly-Boo",
		"Scripts", "Standard Assets", "Pro Standard Assets"
	};

	private static readonly string[] ThirdPartyIndicators = {
		"Plugins", "ThirdParty", "External", "Packages",
		"mscorlib", "System.", "Unity.Timeline", "Unity.Analytics", "Unity.Advertisements"
	};

	private static readonly string[] SystemAssemblyPrefixes = {
		"System.", "Microsoft.", "mscorlib", "netstandard", "Mono."
	};

	private static readonly string[] UnityAssemblyPrefixes = {
		"Assembly-CSharp", "Assembly-UnityScript", "Assembly-Boo", "Unity."
	};

	public FilterManager(Options options)
	{
		_options = options ?? throw new ArgumentNullException(nameof(options));

		_assemblyRegex = CreateRegex(_options.AssemblyFilter);
		_excludeRegex = CreateRegex(_options.ExcludePattern);
		_random = new Random(42); // Deterministic sampling
	}

	// Assembly filtering methods
	public List<AssemblyDefinition> GetFilteredAssemblies(AssetRipper.Import.Structure.Assembly.Managers.IAssemblyManager assemblyManager)
	{
		var assemblies = assemblyManager.GetAssemblies().ToList();

		if (_options.Verbose)
			Logger.Info(LogCategory.Export, $"Found {assemblies.Count} total assemblies");

		// Apply Unity-only filter first
		if (_options.UnityProjectOnly)
		{
			assemblies = assemblies.Where(a => IsUnityAssembly(a.Name ?? "")).ToList();
			if (_options.Verbose)
				Logger.Info(LogCategory.Export, $"Unity-only filter: {assemblies.Count} assemblies remain");
		}

		// Apply assembly name filter
		if (_assemblyRegex != null)
		{
			try
			{
				assemblies = assemblies.Where(a => _assemblyRegex.IsMatch(a.Name ?? "")).ToList();
				if (_options.Verbose)
					Logger.Info(LogCategory.Export, $"Assembly filter '{_options.AssemblyFilter}': {assemblies.Count} assemblies remain");
			}
			catch (Exception ex)
			{
				Logger.Warning(LogCategory.Export, $"Error applying assembly filter: {ex.Message}");
			}
		}

		if (_options.Verbose && assemblies.Any())
		{
			Logger.Info(LogCategory.Export, "Final assembly list:");
			assemblies.ForEach(a => Logger.Info(LogCategory.Export, $"  - {a.Name}"));
		}

		return assemblies;
	}

	public bool ShouldProcessAssembly(string assemblyName)
	{
		// Apply Unity-only filter
		if (_options.UnityProjectOnly && !IsUnityAssembly(assemblyName))
			return false;

		// Apply assembly name filter
		if (_assemblyRegex != null)
		{
			return _assemblyRegex.IsMatch(assemblyName);
		}

		return true;
	}

	private static bool IsUnityAssembly(string assemblyName)
	{
		// Skip system assemblies
		if (SystemAssemblyPrefixes.Any(prefix => assemblyName.StartsWith(prefix, StringComparison.OrdinalIgnoreCase)))
			return false;

		// Include Unity project assemblies
		if (UnityAssemblyPrefixes.Any(prefix => assemblyName.StartsWith(prefix, StringComparison.OrdinalIgnoreCase)))
			return true;

		// Default to include for custom assemblies (unless explicitly Unity-only)
		return true;
	}

	// File filtering methods
	public IEnumerable<FileInfo> GetFilteredFiles(DirectoryInfo scriptsDirectory)
	{
		var csFiles = scriptsDirectory.EnumerateFiles("*.cs", SearchOption.AllDirectories);
		return ApplyBasicFiltering(csFiles);
	}

	public bool ShouldProcessFile(FileInfo file)
	{
		// Exclusion pattern check
		if (_excludeRegex?.IsMatch(file.FullName) == true)
			return false;

		// Auto-generated file check
		if (_options.SkipAutoGenerated && IsAutoGeneratedFile(file))
			return false;

		// File size check
		if (_options.MaxFileSizeBytes > 0 && file.Length > _options.MaxFileSizeBytes)
			return false;

		return true;
	}

	public string GetExclusionReason(FileInfo file)
	{
		if (_excludeRegex?.IsMatch(file.FullName) == true)
			return "exclusion pattern";

		if (_options.SkipAutoGenerated && IsAutoGeneratedFile(file))
			return "auto-generated";

		if (_options.MaxFileSizeBytes > 0 && file.Length > _options.MaxFileSizeBytes)
			return $"too large ({file.Length} bytes)";

		if (_assemblyRegex?.IsMatch(file.DirectoryName ?? "") == false)
			return "assembly filter";

		if (_options.UnityProjectOnly && !IsUnityProjectFile(file))
			return "not Unity project file";

		return "sampling";
	}

	private IEnumerable<FileInfo> ApplyBasicFiltering(IEnumerable<FileInfo> files)
	{
		foreach (var file in files)
		{
			// Assembly filter (check if file is in filtered assembly directory)
			if (_assemblyRegex != null && !_assemblyRegex.IsMatch(file.DirectoryName ?? ""))
				continue;

			// Unity-only filter
			if (_options.UnityProjectOnly && !IsUnityProjectFile(file))
				continue;

			// Standard file filters
			if (!ShouldProcessFile(file))
				continue;

			// Sampling
			if (_options.SampleRate < 1.0 && _random.NextDouble() >= _options.SampleRate)
				continue;

			yield return file;
		}
	}

	private static bool IsAutoGeneratedFile(FileInfo file)
	{
		string fileName = file.Name;
		string directory = file.DirectoryName ?? "";

		// Check file patterns
		if (AutoGeneratedPatterns.Any(pattern =>
			fileName.Contains(pattern, StringComparison.OrdinalIgnoreCase)))
		{
			return true;
		}

		// Check directory patterns
		return AutoGeneratedDirectories.Any(dirPattern =>
			directory.Contains(dirPattern, StringComparison.OrdinalIgnoreCase));
	}

	private static bool IsUnityProjectFile(FileInfo file)
	{
		string directory = file.DirectoryName ?? "";

		// Skip third-party files
		if (ThirdPartyIndicators.Any(indicator =>
			directory.Contains(indicator, StringComparison.OrdinalIgnoreCase)))
		{
			return false;
		}

		// Include Unity project files
		if (UnityProjectIndicators.Any(indicator =>
			directory.Contains(indicator, StringComparison.OrdinalIgnoreCase)))
		{
			return true;
		}

		return true; // Default to include
	}

	private static Regex? CreateRegex(string? pattern)
	{
		if (string.IsNullOrEmpty(pattern))
			return null;

		try
		{
			return new Regex(pattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
		}
		catch (ArgumentException)
		{
			// Invalid regex - return null to disable filtering
			return null;
		}
	}
}
