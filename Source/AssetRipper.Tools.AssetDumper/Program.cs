using AssetRipper.Import.Logging;
using CommandLine;
using System.Text.RegularExpressions;

namespace AssetRipper.Tools.AssetDumper;

internal static class Program
{
	private const int MaxErrorsToShow = 5;

	public static int Main(string[] args)
	{
		Logger.Add(new ConsoleLogger(false));
		Logger.LogSystemInformation("AssetDumper");

		return Parser.Default.ParseArguments<Options>(args)
			.MapResult(
				options => RunWithOptions(options),
				errors => HandleParseErrors(errors)
			);
	}

	private static int RunWithOptions(Options options)
	{
		try
		{
			ConfigureLogging(options);

			var validationResult = ValidateOptions(options);
			if (validationResult != 0)
				return validationResult;

			var processor = new AssetProcessor(options);
			return processor.ProcessAssets();
		}
		catch (Exception ex)
		{
			Logger.Error("Unexpected error occurred", ex);
			return 1;
		}
	}

	private static void ConfigureLogging(Options options)
	{
		// Configure verbosity and silent mode
		if (options.Silent && options.Verbose)
		{
			Logger.Warning("Both --silent and --verbose specified. Verbose mode takes precedence.");
			options.Silent = false;
		}

		if (options.Verbose)
		{
			Logger.AllowVerbose = true;
			Logger.Verbose("Verbose logging enabled");
		}
		// Note: Silent mode is handled in individual logging calls throughout the application
		// by checking options.Silent before calling Logger methods
	}

	private static int ValidateOptions(Options options)
	{
		try
		{
			// Validate input path
			if (!Directory.Exists(options.InputPath) && !File.Exists(options.InputPath))
			{
				Logger.Error($"Input path does not exist: {options.InputPath}");
				return 2;
			}

			// Validate sample rate
			if (options.SampleRate <= 0 || options.SampleRate > 1.0)
			{
				Logger.Error($"Sample rate must be between 0 and 1.0, got: {options.SampleRate}");
				return 4;
			}

			// Validate parallel degree
			if (options.ParallelDegree < 0)
			{
				Logger.Error($"Parallel degree must be >= 0, got: {options.ParallelDegree}");
				return 4;
			}

			// Validate regex patterns
			if (!ValidateRegexPattern(options.AssemblyFilter, "assembly filter"))
				return 4;

			if (!ValidateRegexPattern(options.ExcludePattern, "exclude pattern"))
				return 4;

			if (!ValidateRegexPattern(options.SceneFilter, "scene filter"))
				return 4;

			// Validate numeric options
			if (options.MaxFileSizeBytes < 0)
			{
				Logger.Error("Max file size cannot be negative");
				return 4;
			}

			if (options.MinimumLines < 0)
			{
				Logger.Error("Minimum lines cannot be negative");
				return 4;
			}

			// Create and validate output directory
			try
			{
				Directory.CreateDirectory(options.OutputPath);
			}
			catch (Exception ex)
			{
				Logger.Error($"Cannot create output directory: {ex.Message}");
				return 3;
			}

			// Log validation success
			if (options.Verbose)
			{
				Logger.Info("Options validation completed successfully");
				LogConfigurationSummary(options);
			}
			else if (!options.Silent)
			{
				Logger.Info($"Input: {options.InputPath} -> Output: {options.OutputPath}");
			}

			return 0;
		}
		catch (Exception ex)
		{
			Logger.Error($"Validation error: {ex.Message}");
			return 1;
		}
	}

	private static void LogConfigurationSummary(Options options)
	{
		Logger.Info("=== Configuration Summary ===");
		Logger.Info($"Input Path: {options.InputPath}");
		Logger.Info($"Output Path: {options.OutputPath}");
		Logger.Info($"Export Scripts: {options.ExportScripts}");
		Logger.Info($"Generate AST: {options.GenerateAst}");
		Logger.Info($"Export Scenes: {options.ExportScenes}");
		Logger.Info($"Export Assemblies: {options.ExportAssemblies}");
		Logger.Info($"Export Script Metadata: {options.ExportScriptMetadata}");
		Logger.Info($"Sample Rate: {options.SampleRate:P0}");
		Logger.Info($"Unity Project Only: {options.UnityProjectOnly}");
		Logger.Info($"Skip Auto-Generated: {options.SkipAutoGenerated}");
		Logger.Info($"Incremental Processing: {options.IncrementalProcessing}");
		Logger.Info($"Parallel Degree: {(options.ParallelDegree == 0 ? "Auto" : options.ParallelDegree.ToString())}");

		if (!string.IsNullOrEmpty(options.AssemblyFilter))
			Logger.Info($"Assembly Filter: {options.AssemblyFilter}");
		if (!string.IsNullOrEmpty(options.ExcludePattern))
			Logger.Info($"Exclude Pattern: {options.ExcludePattern}");
		if (!string.IsNullOrEmpty(options.SceneFilter))
			Logger.Info($"Scene Filter: {options.SceneFilter}");

		Logger.Info("==============================");
	}

	private static bool ValidateRegexPattern(string? pattern, string patternName)
	{
		if (string.IsNullOrEmpty(pattern))
			return true;

		try
		{
			var _ = new Regex(pattern, RegexOptions.IgnoreCase);
			return true;
		}
		catch (Exception ex)
		{
			Logger.Error($"Invalid {patternName} regex pattern: {ex.Message}");
			return false;
		}
	}

	private static int HandleParseErrors(IEnumerable<CommandLine.Error> errors)
	{
		Logger.Error("Invalid command line arguments. Use --help for usage information.");

		// Log specific errors (limit to prevent spam)
		var errorList = errors.Take(MaxErrorsToShow).ToList();
		foreach (var error in errorList)
		{
			Logger.Error($"Parse error: {error}");
		}

		if (errors.Count() > MaxErrorsToShow)
		{
			Logger.Error($"... and {errors.Count() - MaxErrorsToShow} more errors");
		}

		return 1;
	}
}
