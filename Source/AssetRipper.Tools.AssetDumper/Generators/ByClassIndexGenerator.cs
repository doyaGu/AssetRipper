using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Import.Logging;
using AssetRipper.Processing;
using AssetRipper.Tools.AssetDumper.Helpers;
using Newtonsoft.Json;
using AssetRipper.Tools.AssetDumper.Core;

namespace AssetRipper.Tools.AssetDumper.Generators;

/// <summary>
/// Generates by_class index as defined in whitepaper section 6.3.
/// Groups assets by their classKey for fast type-based queries.
/// Includes type metadata (className, classId) for improved readability and external tool integration.
/// </summary>
internal sealed class ByClassIndexGenerator
{
	private readonly Options _options;
	private readonly CompressionKind _compressionKind;

	public ByClassIndexGenerator(Options options, CompressionKind compressionKind)
	{
		_options = options ?? throw new ArgumentNullException(nameof(options));
		_compressionKind = compressionKind;
	}

	/// <summary>
	/// Generate by_class index from game data.
	/// Returns path to generated file, or null if generation was skipped.
	/// </summary>
	public string? Generate(GameData gameData, TypeDictionaryBuilder typeDictionary)
	{
		if (!_options.ExportIndexes)
		{
			return null;
		}

		// Note: Current implementation only supports uncompressed mode
		if (_compressionKind != CompressionKind.None)
		{
			if (_options.Verbose)
			{
				Logger.Verbose("by_class index generation is only available in uncompressed mode");
			}
			return null;
		}

		try
		{
			if (!_options.Silent)
			{
				Logger.Info("Generating by_class index...");
			}

			// Build index: classKey -> (metadata, asset PKs)
			Dictionary<int, ClassIndexEntry> classIndex = new();

			// Collect all assets grouped by classKey
			foreach (AssetCollection collection in gameData.GameBundle.FetchAssetCollections())
			{
				string collectionId = ExportHelper.ComputeCollectionId(collection);

				foreach (IUnityObjectBase asset in collection)
				{
					// Get asset metadata (includes classId, typeId, scriptTypeIndex)
					SerializedObjectMetadata metadata = SerializedObjectMetadata.FromAsset(asset);
					
					// Get or assign classKey via TypeDictionary
					int classKey = typeDictionary.GetOrAdd(asset, metadata);

					// Get or create index entry
					if (!classIndex.ContainsKey(classKey))
					{
						string className = asset.ClassName ?? $"ClassID_{metadata.ClassId}";
						classIndex[classKey] = new ClassIndexEntry
						{
							ClassKey = classKey,
							ClassName = className,
							ClassId = metadata.ClassId,
							Assets = new List<AssetPK>()
						};
					}

					// Add asset PK
					classIndex[classKey].Assets.Add(new AssetPK
					{
						CollectionId = collectionId,
						PathId = asset.PathID
					});
				}
			}

			// Sort assets within each class for deterministic output
			foreach (ClassIndexEntry entry in classIndex.Values)
			{
				entry.Assets.Sort((a, b) =>
				{
					int collectionCompare = string.CompareOrdinal(a.CollectionId, b.CollectionId);
					return collectionCompare != 0 ? collectionCompare : a.PathId.CompareTo(b.PathId);
				});
			}

			// Write index as NDJSON (one line per classKey)
			string indexRoot = OutputPathHelper.EnsureSubdirectory(
				_options.OutputPath,
				OutputPathHelper.IndexesDirectoryName);
			
			string fileName = "by_class.ndjson";
			string absolutePath = Path.Combine(indexRoot, fileName);

			using (StreamWriter writer = new StreamWriter(absolutePath))
			{
				// Sort by classKey for deterministic output
				foreach (ClassIndexEntry entry in classIndex.Values.OrderBy(e => e.ClassKey))
				{
					var indexRecord = new
					{
						domain = "by_class",
						classKey = entry.ClassKey,
						assets = entry.Assets,
						count = entry.Assets.Count,
						className = entry.ClassName,
						classId = entry.ClassId
					};

					string json = JsonConvert.SerializeObject(indexRecord, Formatting.None);
					writer.WriteLine(json);
				}
			}

			if (!_options.Silent)
			{
				int totalAssets = classIndex.Values.Sum(e => e.Assets.Count);
				Logger.Info($"Generated by_class index with {classIndex.Count} classes and {totalAssets} total assets");
			}

			return absolutePath;
		}
		catch (Exception ex)
		{
			Logger.Error(LogCategory.Export, $"Failed to generate by_class index: {ex.Message}");
			return null;
		}
	}

	/// <summary>
	/// Internal class for building index entries.
	/// </summary>
	private class ClassIndexEntry
	{
		public int ClassKey { get; set; }
		public string ClassName { get; set; } = string.Empty;
		public int ClassId { get; set; }
		public List<AssetPK> Assets { get; set; } = new List<AssetPK>();
	}

	/// <summary>
	/// Asset primary key reference.
	/// </summary>
	private class AssetPK
	{
		[JsonProperty("collectionId")]
		public string CollectionId { get; set; } = string.Empty;

		[JsonProperty("pathId")]
		public long PathId { get; set; }
	}
}
