using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Import.Logging;
using AssetRipper.Processing;
using AssetRipper.Tools.AssetDumper.Helpers;
using Newtonsoft.Json;

using AssetRipper.Tools.AssetDumper.Core;

namespace AssetRipper.Tools.AssetDumper.Generators;

/// <summary>
/// Generates by_class index as defined in whitepaper section 6.3.
/// Groups assets by their classKey for fast type-based queries.
/// </summary>
internal sealed class ByClassIndexGenerator
{
	private readonly Options _options;
	private readonly CompressionKind _compressionKind;

	public ByClassIndexGenerator(Options options, CompressionKind compressionKind)
	{
		_options = options ?? throw new ArgumentNullException(nameof(options));
		_compressionKind = compressionKind;
	}

	/// <summary>
	/// Generate by_class index from game data.
	/// Returns path to generated file, or null if generation was skipped.
	/// </summary>
	public string? Generate(GameData gameData, TypeDictionaryBuilder typeDictionary)
	{
		if (!_options.ExportIndexes)
		{
			return null;
		}

		// Note: Current implementation only supports uncompressed mode
		if (_compressionKind != CompressionKind.None)
		{
			if (_options.Verbose)
			{
				Logger.Verbose("by_class index generation is only available in uncompressed mode");
			}
			return null;
		}

		try
		{
			if (!_options.Silent)
			{
				Logger.Info("Generating by_class index...");
			}

			Dictionary<int, List<AssetPK>> classToPKs = new();

			// Collect all assets grouped by classId
			foreach (AssetCollection collection in gameData.GameBundle.FetchAssetCollections())
			{
				string collectionId = collection.Name; // Simplified - should use stable ID

				foreach (IUnityObjectBase asset in collection)
				{
					int classId = asset.ClassID;

					if (!classToPKs.ContainsKey(classId))
					{
						classToPKs[classId] = new List<AssetPK>();
					}

					classToPKs[classId].Add(new AssetPK
					{
						CollectionId = collectionId,
						PathId = asset.PathID
					});
				}
			}

			// Write index as NDJSON (one line per classKey)
			string indexRoot = OutputPathHelper.EnsureSubdirectory(
				_options.OutputPath,
				OutputPathHelper.IndexesDirectoryName);
			
			string fileName = "by_class.ndjson";
			string absolutePath = Path.Combine(indexRoot, fileName);

			using (StreamWriter writer = new StreamWriter(absolutePath))
			{
				foreach (KeyValuePair<int, List<AssetPK>> kvp in classToPKs.OrderBy(k => k.Key))
				{
					// Use classId directly as the key - TypeDictionary is only for complex type metadata
					int classKey = kvp.Key;

					var indexEntry = new
					{
						classKey = classKey,
						assets = kvp.Value
					};

					string json = JsonConvert.SerializeObject(indexEntry, Formatting.None);
					writer.WriteLine(json);
				}
			}

			if (!_options.Silent)
			{
				Logger.Info($"Generated by_class index with {classToPKs.Count} classes");
			}

			return absolutePath;
		}
		catch (Exception ex)
		{
			Logger.Error(LogCategory.Export, $"Failed to generate by_class index: {ex.Message}");
			return null;
		}
	}

	private class AssetPK
	{
		[JsonProperty("collectionId")]
		public string CollectionId { get; set; } = string.Empty;

		[JsonProperty("pathId")]
		public long PathId { get; set; }
	}
}
