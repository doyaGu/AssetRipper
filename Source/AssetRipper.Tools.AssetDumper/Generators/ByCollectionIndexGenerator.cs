using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Import.Logging;
using AssetRipper.Processing;
using Newtonsoft.Json;
using AssetRipper.Tools.AssetDumper.Core;
using AssetRipper.Tools.AssetDumper.Helpers;

namespace AssetRipper.Tools.AssetDumper.Generators;

/// <summary>
/// Generates by_collection index providing collection-level summaries.
/// Includes asset counts and type distribution for each collection.
/// </summary>
internal sealed class ByCollectionIndexGenerator
{
	private readonly Options _options;

	public ByCollectionIndexGenerator(Options options)
	{
		_options = options ?? throw new ArgumentNullException(nameof(options));
	}

	/// <summary>
	/// Generate by_collection index from game data.
	/// Returns path to generated file, or null if generation was skipped.
	/// </summary>
	public string? Generate(GameData gameData)
	{
		if (!_options.ExportIndexes)
		{
			return null;
		}

		try
		{
			if (!_options.Silent)
			{
				Logger.Info("Generating by_collection index...");
			}

			Dictionary<string, CollectionSummary> summaries = new();

			// Collect summaries for each collection
			foreach (AssetCollection collection in gameData.GameBundle.FetchAssetCollections())
			{
				string collectionId = collection.Name; // Simplified - should use stable ID
				
				CollectionSummary summary = new CollectionSummary
				{
					CollectionId = collectionId,
					Count = collection.Count
				};

				// Count by type
				Dictionary<int, int> typeCounts = new();
				foreach (IUnityObjectBase asset in collection)
				{
					int classId = asset.ClassID;
					if (!typeCounts.ContainsKey(classId))
					{
						typeCounts[classId] = 0;
					}
					typeCounts[classId]++;
				}

				summary.TypeDistribution = typeCounts
					.OrderByDescending(kvp => kvp.Value)
					.Take(10) // Top 10 types
					.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);

				summaries[collectionId] = summary;
			}

			// Write as JSON (small enough for single file)
			string indexRoot = OutputPathHelper.EnsureSubdirectory(
				_options.OutputPath,
				OutputPathHelper.IndexesDirectoryName);
			
			string fileName = "by_collection.json";
			string absolutePath = Path.Combine(indexRoot, fileName);

			string json = JsonConvert.SerializeObject(summaries, Formatting.Indented);
			File.WriteAllText(absolutePath, json);

			if (!_options.Silent)
			{
				Logger.Info($"Generated by_collection index with {summaries.Count} collections");
			}

			return absolutePath;
		}
		catch (Exception ex)
		{
			Logger.Error(LogCategory.Export, $"Failed to generate by_collection index: {ex.Message}");
			return null;
		}
	}

	private class CollectionSummary
	{
		[JsonProperty("collectionId")]
		public string CollectionId { get; set; } = string.Empty;

		[JsonProperty("count")]
		public int Count { get; set; }

		[JsonProperty("typeDistribution")]
		public Dictionary<int, int> TypeDistribution { get; set; } = new();
	}
}
