using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Assets.Metadata;
using AssetRipper.Import.Logging;
using AssetRipper.Processing;
using Newtonsoft.Json;
using AssetRipper.Tools.AssetDumper.Core;
using AssetRipper.Tools.AssetDumper.Helpers;

namespace AssetRipper.Tools.AssetDumper.Generators;

/// <summary>
/// Generates by_collection index providing collection-level summaries.
/// Includes asset counts, type distribution, and collection metadata for fast statistics.
/// </summary>
internal sealed class ByCollectionIndexGenerator
{
	private readonly Options _options;

	public ByCollectionIndexGenerator(Options options)
	{
		_options = options ?? throw new ArgumentNullException(nameof(options));
	}

	/// <summary>
	/// Generate by_collection index from game data.
	/// Returns path to generated file, or null if generation was skipped.
	/// </summary>
	public string? Generate(GameData gameData)
	{
		if (!_options.ExportIndexes)
		{
			return null;
		}

		try
		{
			if (!_options.Silent)
			{
				Logger.Info("Generating by_collection index...");
			}

			// Build TypeDictionary for classKey assignment
			TypeDictionaryBuilder typeDictionary = new TypeDictionaryBuilder();
			
			// First pass: populate TypeDictionary
			foreach (AssetCollection collection in gameData.GameBundle.FetchAssetCollections())
			{
				foreach (IUnityObjectBase asset in collection)
				{
					SerializedObjectMetadata metadata = SerializedObjectMetadata.FromAsset(asset);
					typeDictionary.GetOrAdd(asset, metadata);
				}
			}

			List<CollectionSummary> summaries = new();

			// Second pass: collect summaries for each collection
			foreach (AssetCollection collection in gameData.GameBundle.FetchAssetCollections())
			{
				string collectionId = collection.Name;
				
				CollectionSummary summary = new CollectionSummary
				{
					CollectionId = collectionId,
					Name = collection.Name,
					Count = collection.Count,
					IsScene = collection.IsScene,
					BundleName = collection.Bundle.Name
				};

				// Count by classKey and collect metadata
				Dictionary<int, TypeDistributionEntry> typeEntries = new();
				
				foreach (IUnityObjectBase asset in collection)
				{
					SerializedObjectMetadata metadata = SerializedObjectMetadata.FromAsset(asset);
					int classKey = typeDictionary.GetOrAdd(asset, metadata);

					if (!typeEntries.ContainsKey(classKey))
					{
						string className = asset.ClassName ?? $"ClassID_{metadata.ClassId}";
						typeEntries[classKey] = new TypeDistributionEntry
						{
							ClassKey = classKey,
							ClassName = className,
							ClassId = metadata.ClassId,
							Count = 0
						};
					}
					typeEntries[classKey].Count++;
				}

				// Sort by count descending and take top 10
				summary.TypeDistribution = typeEntries.Values
					.OrderByDescending(e => e.Count)
					.Take(10)
					.ToList();

				summary.TotalTypeCount = typeEntries.Count;

				summaries.Add(summary);
			}

			// Sort collections by ID for deterministic output
			summaries.Sort((a, b) => string.CompareOrdinal(a.CollectionId, b.CollectionId));

			// Write as JSON array (small enough for single file)
			string indexRoot = OutputPathHelper.EnsureSubdirectory(
				_options.OutputPath,
				OutputPathHelper.IndexesDirectoryName);
			
			string fileName = "by_collection.json";
			string absolutePath = Path.Combine(indexRoot, fileName);

			string json = JsonConvert.SerializeObject(summaries, Formatting.Indented);
			File.WriteAllText(absolutePath, json);

			int totalAssets = summaries.Sum(s => s.Count);
			if (!_options.Silent)
			{
				Logger.Info($"Generated by_collection index with {summaries.Count} collections and {totalAssets} total assets");
			}

			return absolutePath;
		}
		catch (Exception ex)
		{
			Logger.Error(LogCategory.Export, $"Failed to generate by_collection index: {ex.Message}");
			return null;
		}
	}

	/// <summary>
	/// Summary record for a single collection.
	/// </summary>
	private class CollectionSummary
	{
		[JsonProperty("domain")]
		public string Domain { get; set; } = "by_collection";

		[JsonProperty("collectionId")]
		public string CollectionId { get; set; } = string.Empty;

		[JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
		public string? Name { get; set; }

		[JsonProperty("count")]
		public int Count { get; set; }

		[JsonProperty("isScene", NullValueHandling = NullValueHandling.Ignore)]
		public bool? IsScene { get; set; }

		[JsonProperty("bundleName", NullValueHandling = NullValueHandling.Ignore)]
		public string? BundleName { get; set; }

		[JsonProperty("typeDistribution", NullValueHandling = NullValueHandling.Ignore)]
		public List<TypeDistributionEntry>? TypeDistribution { get; set; }

		[JsonProperty("totalTypeCount", NullValueHandling = NullValueHandling.Ignore)]
		public int? TotalTypeCount { get; set; }
	}

	/// <summary>
	/// Type distribution entry with classKey, className, classId, and count.
	/// </summary>
	private class TypeDistributionEntry
	{
		[JsonProperty("classKey")]
		public int ClassKey { get; set; }

		[JsonProperty("className", NullValueHandling = NullValueHandling.Ignore)]
		public string? ClassName { get; set; }

		[JsonProperty("classId", NullValueHandling = NullValueHandling.Ignore)]
		public int? ClassId { get; set; }

		[JsonProperty("count")]
		public int Count { get; set; }
	}
}
