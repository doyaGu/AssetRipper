using AssetRipper.Assets;
using AssetRipper.Assets.Collections;
using AssetRipper.Import.Logging;
using AssetRipper.Processing;
using AssetRipper.Tools.AssetDumper.Helpers;
using Newtonsoft.Json;
using AssetRipper.Tools.AssetDumper.Core;
using System.Diagnostics.CodeAnalysis;

namespace AssetRipper.Tools.AssetDumper.Generators;

/// <summary>
/// Generates by_name index for fast asset name-based queries.
/// Provides a lookup table mapping asset names to their locations.
/// </summary>
internal sealed class ByNameIndexGenerator
{
	private readonly Options _options;
	private readonly CompressionKind _compressionKind;

	public ByNameIndexGenerator(Options options, CompressionKind compressionKind)
	{
		_options = options ?? throw new ArgumentNullException(nameof(options));
		_compressionKind = compressionKind;
	}

	/// <summary>
	/// Generate by_name index from game data.
	/// Returns path to generated file, or null if generation was skipped.
	/// </summary>
	public string? Generate(GameData gameData)
	{
		if (!_options.ExportIndexes)
		{
			return null;
		}

		// Note: Current implementation only supports uncompressed mode
		if (_compressionKind != CompressionKind.None)
		{
			if (_options.Verbose)
			{
				Logger.Verbose("by_name index generation is only available in uncompressed mode");
			}
			return null;
		}

		try
		{
			if (!_options.Silent)
			{
				Logger.Info("Generating by_name index...");
			}

			// Dictionary to store name -> list of asset locations
			Dictionary<string, List<AssetLocation>> nameToAssets = new();
			int processedAssets = 0;
			int namedAssets = 0;

			// Collect all named assets
			foreach (AssetCollection collection in gameData.GameBundle.FetchAssetCollections())
			{
				string collectionId = ExportHelper.ComputeCollectionId(collection);

				foreach (IUnityObjectBase asset in collection)
				{
					processedAssets++;
					
					// Get asset name - different asset types store names differently
					string? assetName = GetAssetName(asset);
					
					if (string.IsNullOrWhiteSpace(assetName))
					{
						continue; // Skip unnamed assets
					}

					namedAssets++;

					if (!nameToAssets.ContainsKey(assetName))
					{
						nameToAssets[assetName] = new List<AssetLocation>();
					}

					nameToAssets[assetName].Add(new AssetLocation
					{
						CollectionId = collectionId,
						PathId = asset.PathID,
						ClassId = asset.ClassID,
						ClassName = asset.ClassName ?? $"Unknown_{asset.ClassID}"
					});
				}
			}

			// Write index as NDJSON (one line per asset name)
			string indexRoot = OutputPathHelper.EnsureSubdirectory(
				_options.OutputPath,
				OutputPathHelper.IndexesDirectoryName);
			
			string fileName = "by_name.ndjson";
			string absolutePath = Path.Combine(indexRoot, fileName);

			using (StreamWriter writer = new StreamWriter(absolutePath))
			{
				// Sort by name for better searchability
				foreach (KeyValuePair<string, List<AssetLocation>> kvp in nameToAssets.OrderBy(k => k.Key))
				{
					var indexEntry = new
					{
						domain = "by_name",
						name = kvp.Key,
						locations = kvp.Value.Select(loc => new
						{
							collectionId = loc.CollectionId,
							pathId = loc.PathId,
							classId = loc.ClassId,
							className = loc.ClassName
						}).ToList()
					};

					string json = JsonConvert.SerializeObject(indexEntry, Formatting.None);
					writer.WriteLine(json);
				}
			}

			if (!_options.Silent)
			{
				Logger.Info($"Generated by_name index with {nameToAssets.Count} unique names from {namedAssets}/{processedAssets} assets");
			}

			return absolutePath;
		}
		catch (Exception ex)
		{
			Logger.Error(LogCategory.Export, $"Failed to generate by_name index: {ex.Message}");
			return null;
		}
	}

	/// <summary>
	/// Extract name from asset using reflection to access the Name property if available.
	/// </summary>
	[UnconditionalSuppressMessage("Trimming", "IL2075", Justification = "Dynamic reflection on Unity asset types is intentional and required for name extraction")]
	private string? GetAssetName(IUnityObjectBase asset)
	{
		try
		{
			// Try to use the common GetBestName() extension method if available
			// Most NamedObject types have a Name property
			Type type = asset.GetType();
			System.Reflection.PropertyInfo? nameProperty = type.GetProperty("Name");
			
			if (nameProperty != null)
			{
				object? value = nameProperty.GetValue(asset);
				if (value is string name && !string.IsNullOrWhiteSpace(name))
				{
					return name;
				}
			}

			// Fallback: try m_Name field (common in Unity serialization)
			System.Reflection.FieldInfo? nameField = type.GetField("m_Name");
			if (nameField != null)
			{
				object? value = nameField.GetValue(asset);
				if (value is string name && !string.IsNullOrWhiteSpace(name))
				{
					return name;
				}
			}

			return null;
		}
		catch
		{
			return null;
		}
	}

	private class AssetLocation
	{
		public string CollectionId { get; set; } = string.Empty;
		public long PathId { get; set; }
		public int ClassId { get; set; }
		public string ClassName { get; set; } = string.Empty;
	}
}
